#!/bin/bash
#
# Shell script for packer's shell provisioner.

sleep 30

echo "!!! Start of provisioner script !!!"

PROGRAM_NAME=$(basename "$0")
NETWORK_DEV_PATH="/sys/class/net"
SSH_DIR_PATH="${HOME}/.ssh"
GITHUB_USER_NAME="cavcrosby"
# y ==> yes
JENKINS_INFRASTRUCTURE_REPO_URL="https://${GITHUB_USER_NAME}:${GITHUB_SECRET}@github.com/${GITHUB_USER_NAME}/jenkins-infrastructure.git"
JENKINS_INFRASTRUCTURE_REPO_NAME="$(basename "$JENKINS_INFRASTRUCTURE_REPO_URL")"
# NOTE: can add more types of NICs as needed, the globs may change 
# depending on naming scheme used for NICs, for reference see:
# https://www.freedesktop.org/software/systemd/man/systemd.net-naming-scheme.html
LOOPBACK_INTERFACE_GLOB="loopback_interface_glob"
ETHERNET_INTERFACE_GLOB="ethernet_interface_glob"
loopback_interfaces_counter=0
ethernet_interfaces_counter=0
declare -A NIC_GLOBS=(
    ["$LOOPBACK_INTERFACE_GLOB"]="lo*"
    ["$ETHERNET_INTERFACE_GLOB"]="en*"
)
SYSTEM_DEPENDENCIES=(
    build-essential
    curl
    git
    gnupg
    python3
    sudo
    wget
)

# normal VM updating, upgrading distro pkgs
echo "$SSH_PASSWORD" | sudo --stdin apt-get update
echo "$SSH_PASSWORD" | sudo --stdin apt-get dist-upgrade --assume-yes

# NOTES: installs some 'nice to have' pkgs. Also
# makes sure I am part of the sudoer group!
echo "$SSH_PASSWORD" | sudo --stdin apt-get install "${SYSTEM_DEPENDENCIES[@]}" --assume-yes
echo "$SSH_PASSWORD" | sudo --stdin usermod --append --groups sudo "$SSH_USER"

# grab common provisioner configurations
wget "http://${PACKER_HTTP_ADDR}/${SHELL_PROVISIONER_ENV_FILE_NAME}"
# shellcheck disable=1090
. "./${SHELL_PROVISIONER_ENV_FILE_NAME}"

HOSTONLYIF_MACADDR="${!SHELLFUNCS_HOSTONLYIF_MACADDR_ENV_VAR_NAME}"
NATIF_MACADDR="${!SHELLFUNCS_NATIF_MACADDR_ENV_VAR_NAME}"

# NOTES: extract authorized_keys for 'jenkins' user (runner of Jenkins builds).
# Also assumes GIT_REPOS_PATH is just HOME.
git clone "$JENKINS_INFRASTRUCTURE_REPO_URL" "$JENKINS_INFRASTRUCTURE_REPO_NAME"
if ! [ -d "$SSH_DIR_PATH" ]; then mkdir --parents "$SSH_DIR_PATH"; chmod 700 "$SSH_DIR_PATH"; fi
cat "${JENKINS_INFRASTRUCTURE_REPO_NAME}/configs/authorized_keys" >> "${SSH_DIR_PATH}/authorized_keys"

# config sshd, first sed makes backup of original sshd_config (sshd_config.bak)
# sed 's/old_text/new_text/' ... (the three '/'s can be replaced with
# any char, just a delimiter)
echo "$SSH_PASSWORD" | sudo --stdin sed --in-place=.bak --regexp-extended 's|^#?PubkeyAuthentication.+|PubkeyAuthentication yes|' /etc/ssh/sshd_config
echo "$SSH_PASSWORD" | sudo --stdin sed --in-place --regexp-extended 's|^#?PasswordAuthentication.+|PasswordAuthentication no|' /etc/ssh/sshd_config
echo "$SSH_PASSWORD" | sudo --stdin sed --in-place --regexp-extended 's|^#?AuthorizedKeysFile.+|AuthorizedKeysFile    .ssh/authorized_keys|' /etc/ssh/sshd_config
echo "$SSH_PASSWORD" | sudo --stdin systemctl restart sshd

# NOTE: shellcheck did not like my initial implementation when using a for
# loop with find, for reference:
# https://github.com/koalaman/shellcheck/wiki/SC2044
while IFS= read -r nic
do
    # we do want to match on globbing rather than literal expanded str
    # shellcheck disable=2254
    case "$nic" in
        ${NIC_GLOBS["$LOOPBACK_INTERFACE_GLOB"]})   "$((loopback_interfaces_counter++))"
                                                    ;;
        ${NIC_GLOBS["$ETHERNET_INTERFACE_GLOB"]})   "$((ethernet_interfaces_counter++))"
                                                    if [ "$(cat ${NETWORK_DEV_PATH}/"${nic}"/address)" = "$HOSTONLYIF_MACADDR" ]; then
                                                        HOSTONLYIF_NAME="$nic"
                                                    elif [ "$(cat ${NETWORK_DEV_PATH}/"${nic}"/address)" = "$NATIF_MACADDR" ]; then
                                                        NATIF_NAME="$nic"
                                                    else
                                                        echo "${PROGRAM_NAME}: unexpected ethernet interface was found"
                                                        exit 1
                                                    fi
                                                    ;;
    esac
done < <(find ${NETWORK_DEV_PATH} -exec basename '{}' ';')

if [ "$loopback_interfaces_counter" -lt 1 ]; then
    echo "${PROGRAM_NAME}: VM does not have a loopback interface...huh?!?"
    exit 1
fi

if [ "$ethernet_interfaces_counter" -lt 2 ]; then
    echo "${PROGRAM_NAME}: VM was not configured to have two ethernet interfaces"
    exit 1
fi

# NOTES: quoting not needed here for env vars. Also, ok with
# writing to interface file vs creating a new file in interfaces.d
cat << _EOF_ >> "/etc/network/interfaces"
auto $LOOPBACK_NAME $NATIF_NAME $HOSTONLYIF_NAME

iface $LOOPBACK_NAME inet loopback
iface $LOOPBACK_NAME inet6 loopback

iface $NATIF_NAME inet dhcp

iface $HOSTONLYIF_NAME inet static
    address $SHELLFUNCS_VM_IPV4_ADDR
    netmask $SHELLFUNCS_VM_SUBNET_MASK
    gateway $SHELLFUNCS_VM_GATEWAY

_EOF_

# for good practice, disable root account
# credits go to:
# https://unix.stackexchange.com/questions/383301/should-i-disable-the-root-account-on-my-debian-pc-for-security
echo "$SSH_PASSWORD" | sudo passwd --delete root
echo "$SSH_PASSWORD" | sudo passwd --lock root

# packerbuilds.conf MAY contain env vars from build env
wget "http://${PACKER_HTTP_ADDR}/packerbuilds.conf"
echo "$SSH_PASSWORD" | sudo --stdin mv ./packerbuilds.conf /etc/

echo "!!! End of provisioner script !!!"

exit 0
